// This program defines a class Sorting which includes several sorting
// algorithms.  It also illustrates how method closures can be stored
// in an array and then executed one by one (see method map in main).

class Sorting {
  var array : arrayOf int, size:int;

  method Sorting(n:int) {
    var x[n] : arrayOf int;
    print("Type ",n," numbers: ");
    for i = 0 to n - 1 do
      x[i] = read();
    print("Finished reading the ",n," numbers\n");
    array = x;
    size = n;
  }

  method printArray() {
    print("\n");
    for i = 0 to size-1 do
      print(array[i]," ");
    print("\n");
  }

  method reverse() {
    for i = 0 to size/2 - 1 do {
      var t:int = array[i];
      array[i] = array[size - i - 1];
      array[size - i - 1] = t;
    }
  }

  method insertionSort() {
    for i = 1 to size-1 do {
      var v:int = array[i], j:int = i - 1;
      while (j > 0 and array[j] > v) do {  // doing the loop only up to 1
        array[j + 1] = array[j];
        j = j - 1;
      }
      if (array[0] > v) then {
        array[1] = array[0];
        array[0] = v;
      } else array[j+1] = v;
    }
  }

  method bubbleSort() {
    for i = 0 to size - 1 do
      for j = 0 to size - 2 do
        if array[j] > array[j+1] then {
          var t:int = array[j+1];
          array[j+1] = array[j];
          array[j] = t;
        }
  }

  method siftDown(root:int, bottom:int) {
    var done:bool = false, maxChild:int;
    while (root*2 <= bottom and not done) do {
      if (root*2 == bottom) then {
        maxChild = root*2;
      }
      else if (array[root*2] > array[root*2 + 1]) then {
        maxChild = root*2;
      }
      else {
        maxChild = root*2 + 1;
      }
      if (array[root] < array[maxChild]) then {
        var t:int = array[root];
        array[root] = array[maxChild];
        array[maxChild] = t;
        root = maxChild;
      }
      else {
        done = true;
      }
    }
  }

  method heapSort() {
    var i:int = size/2 - 1;
    while (i >= 0) do {
      siftDown(i, size - 1);
      i = i - 1;
    }
    i = size - 1;
    while (i >= 1 ) do {
      var t:int = array[0];
      array[0] = array[i] ;
      array[i] = t;
      siftDown(0, i - 1);
      i = i - 1;
    }
  }

}


class main {

  method map(m : arrayOf string, f : arrayOf function from void to void) {
    for i = 0 to sizeOf(f) - 1 do {
      print(m[i]);
      (f[i])();
    }
  }

  method main() {
    print("Size of the array to sort = ");
    var s : class Sorting = new Sorting(read()),
        m[11] : arrayOf string,
        f[11] : arrayOf function from void to void;
    m[ 0] = "The original unsorted array is:";
    f[ 0] = s.printArray;
    m[ 1] = "Reversing the array ... ";
    f[ 1] = s.reverse;
    m[ 2] = "Done!\nThe reversed array is:";
    f[ 2] = s.printArray;
    m[ 3] = "Sorting the array using insertion sort ... ";
    f[ 3] = s.insertionSort;
    m[ 4] = "Done!\nThe resulting array is:";
    f[ 4] = s.printArray;
    m[ 5] = "Reversing the array ... ";
    f[ 5] = s.reverse;
    m[ 6] = "Done!\nSorting the array using bubble sort ... ";
    f[ 6] = s.bubbleSort;
    m[ 7] = "Done!\nThe resulting array is:";
    f[ 7] = s.printArray;
    m[ 8] = "Reversing the array ... ";
    f[ 8] = s.reverse;
    m[ 9] = "Done!\nSorting the array using heap sort ... ";
    f[ 9] = s.heapSort;
    m[10] = "Done!\nThe resulting array is:";
    f[10] = s.printArray;
    map(m,f);
  }
}
