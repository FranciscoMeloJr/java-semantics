    Test plan for static members.
Part 1. Static methods.
Part 2. Static fields.
Part 3. Static initialization - just static members.
Part 4. Final static fields in interfaces.
Part 5. Triggering static initialization.

Part 6. Implementation of console read/out and others through static members.
  Add required tests in java-api-core section, just the main functionality.
  Also test that other fields/methods may have the same name as builtin native methods.

  Part 1. Static methods

101. Static method call through Class.f() expression.
102. Static method call unqualified, from an instance method.
103. Two static and two instance methods in one class. Call all unqualified
  in an instance context.
104. Static method lookup, all the forms:
  6 possible expressions:
  - unqualified in static context
  - unqualified in instance context
  - this.f()
  - super.f()
  - object.f()
  - Class.f()
  2 possible target contexts:
  - method defined in the target type/ current class
  - method inherited. Test all possibilities.

105. Static method overloading, all versions of the method in one class.
106. Static methods access modes - test just public vs private access mode
  in one compilation unit.
107. Static protected access mode. Test that a static protected method can be
  accessed from a subclass in a different package,
  using an instance qualifier, while a non-static protected cannot.
108. Static method versions from subclasses are not accessible,
  even when calling them through instance qualifier.
  B < A, B.f() <sig A.f(), call to (A)B.f() have no access to B.f().
109. Static methods are not overwritten. B < A, A.f() =sig B.f().
  Call to (A)B.f() calls A.f().
110. Static methods hiding.
  A < B, A.f() =sig B.f(). Other variations by need.
  6 possible expressions:
  - unqualified in static context
  - unqualified in instance context
  - this.f()
  - super.f()
  - object.f()
  - Class.f()
  2 possible target contexts:
  - method defined in the target type/ current class
  - method inherited. Test all possibilities.

  Method hiding is described in: $8.4.8.2, $8.4.8.3

111. Hiding and overloading independence. A < B. A.f(int), A.f(long), B.f(int).
  From B, A.f(long) is visible.
112. Overloading through a mix of static and instance methods.
  Call from instance context. All methods are accessible.
  Class A:
    - f(byte)
    - static f(short)
    - f(int)
    - static f(long)
    Call via:
      - inside instance method, unqualified.
      - this,
      - instance of A,
    with all param types.

113. Overloading through a mix of static and instance methods.
  Call from static context. Only static methods are accessible.
  Class A:
    - f(byte)
    - static f(short)
    - f(int)
    - static f(long)
    Call via:
      - inside static method, unqualified.
      - class name A,
    with param types: short, long. Other ones will give compile-time error.

114. Overloading through a mix of static and instance methods.
  Inheritnace. Call through super.f()
  Class A:
    - f(int)
    - static f(long)
  Class B < A:
    - f(byte)
    - static f(short)
    Call via:
      - super.f() inside B, with all param types.

115. Overwriting vs hiding.
  A: f(), static g().
  B < A: f(), static g(). Call both from (A)a, (B)b, (B)a.

116. Unqualified static method in instance initializing contexts.
  Access a static method through unqualified expression in:
  - instance field initializer
  - instance initializer
  - super() call
  - constructor

