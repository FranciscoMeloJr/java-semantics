Runtime semantics of access mode in the context of overriding and overloading.1. Access mode semantics in the context of method overriding.  Testing that a class may have multiple methods  with the same signature but not in an overloading relation,  due to private/package access mode.  - a.A:    - private f()    - package g()    - protected h()    - public k()    - public call() - calls all four other methods.  - a.B < A:    - public f()    - public g()    - public h()    - public k()  - b.C < A:    - public f()    - public g()    - public h()    - public k()  - A aa, ab, ac. On all three refs execute call().2. Access mode semantics in the context of method overriding.  Non-public access modes in base class, non-public access modes in derived class,    all allowed combinations in two contexts derived in the same package    and derived on other package.  - a.A:    - private f11()    - private f12()    - private f13()    - package g21()    - package g22()    - package g23()    - protected h33()    - public call() - calls all the methods.  - a.B < A:    - private f11()    - package f12()    - protected f13()    - package g22()    - protected g23()    - protected h33()  - b.C < A:    - private f11()    - package f12()    - protected f13()    - private g21()    - package g22()    - protected g23()    - protected h33()  - A ab, ac. On all three refs execute call().3. Access mode semantics in the context of method overloading. Test of accessibility.  Multiple overloaded methods, all potentially applicable, with more specific versions having a  more restricted access specifier. In all contexts, the most restricted accessible method will  be called.  - a.A:    - private f(byte)    - package f(short)    - protected f(int)    - public f(long)    - public call(a.A): calls f(byte) on a.A object    - public call(): calls f(byte) locally  - a.B:    - public call(a.A): calls f(byte) on a.A object  - b.C < A:    - public call(a.A): calls f(byte) on a.A object    - public call(): calls f(byte) locally  - b.D:    - public call(a.A): calls f(byte) on a.A object    - call all six call() methods.todo:(Split the previous test into two parts, the second part being test 4)(Another idea would be to test for all six call() methods four cases:  - private is the most specific  - package is the most specific  - protected is the most specific  - public is the most specific  This way we ensure that mo access mode is more or less visible than it should be.)4. Same as previous test but call f() in class a.A and b.C on another object.  More precisely:   - a.A:    - private f(byte)    - package f(short)    - protected f(int)    - public f(long)    - public call(a.A): calls f(byte) on a.A object  - b.C < A:    - public call(a.A): calls f(byte) on a.A object  - call the two call() methods.  This test ensures that a private method may be called on another object of the same type,  but a protected method cannot.5. Protected access mode and overloading.  Test that protected methods cannot be called using a qualified expression line a.f(),  even if a is the same object as this.    The program should test 3 cases:    - this.f() - ok    - a.f(), a =/= this - protected is inaccessible.    - a.f(), a == this - protected is inaccessible.6. Test getAccessMode() function.  - one method attribute - access mode, for public, protected, private.  - two method attributes, an access mode and final, access mode is first  - two method attributes, an access mode and final, access mode is the second  - no method attributes  - just one attribute - final7. Test 5, but for constructors. Will be implemented once we'll have the ability to call from  a constructor another constructor of the same class.