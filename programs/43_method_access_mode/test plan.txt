Runtime semantics of access mode in the context of overriding and overloading.1. Access mode semantics in the context of method overriding.  Testing that a class may have multiple methods  with the same signature but not in an overloading relation,  due to private/package access mode.  - a.A:    - private f()    - package g()    - protected h()    - public k()    - public call() - calls all four other methods.  - a.B < A:    - public f()    - public g()    - public h()    - public k()  - b.C < A:    - public f()    - public g()    - public h()    - public k()  - A aa, ab, ac. On all three refs execute call().2. Access mode semantics in the context of method overriding.  Non-public access modes in base class, non-public access modes in derived class,    all allowed combinations in two contexts derived in the same package    and derived on other package.  - a.A:    - private f11()    - private f12()    - private f13()    - package g21()    - package g22()    - package g23()    - protected h33()    - public call() - calls all the methods.  - a.B < A:    - private f11()    - package f12()    - protected f13()    - package g22()    - protected g23()    - protected h33()  - b.C < A:    - private f11()    - package f12()    - protected f13()    - private g21()    - package g22()    - protected g23()    - protected h33()  - A ab, ac. On all three refs execute call().3. Access mode semantics in the context of method overloading. Test of accessibility.  Multiple overloaded methods, all potentially applicable, with more specific versions having a  more restricted access specifier. In all contexts, the most restricted accessible method will  be called.  - a.A:    - private f(byte)    - package f(short)    - protected f(int)    - public f(long)    - public call(a.A): calls f(byte) on a.A object    - public call(): calls f(byte) locally  - a.B:    - public call(a.A): calls f(byte) on a.A object  - b.C < A:    - public call(a.A): calls f(byte) on a.A object    - public call(): calls f(byte) locally  - b.D:    - public call(a.A): calls f(byte) on a.A object    - call all six call() methods.4. Same as test 3 but now we have three overloaded methods  in A instead of one: f(), g(), and h(). This is an extensive test of access modes  accessibility.  The difference is the access mode of the most specific version:    - f(byte) is package    - g(byte) is protected    - h(byte) is publicAll methods with all versions are the following:    - private f(short)    - package f(byte)    - protected f(int)    - public f(long)    - private g(short)    - package g(int)    - protected g(byte)    - public g(long)    - private h(short)    - package h(int)    - protected h(long)    - public h(byte)5. Protected access mode and overloading.  Test that protected methods cannot be called using a qualified expression line a.f(),  even if a is the same object as this. Base and derived classes are necessary in  different packages, so that protected mode cannot be interpreted as package mode.  Case when protected can be interpreted as package is covered in the test 4.    The program should test 3 cases:    - this.f() - ok    - a.f(), a =/= this - protected is inaccessible.    - a.f(), a == this - protected is inaccessible.6. Test getAccessMode() rule - access mode present  - one method attribute - access mode, for protected.  - two method attributes, an access mode and final, access mode is first  - two method attributes, an access mode and final, access mode is the second  The tested access mode will be protected, the method will have two versions:  protected and package. This way we ensure that package is not selected instead of protected.7. Test getAccessMode() rule - access mode not present  - no method attributes  - just one attribute - final  When testing package access mode, we'll also have protected and package versions, protected is more specific, but not accessible. This way we can distinguish between versions.Part 2. Interplay of overloading, overwriting and access modes at the same time.    This part explores the semantic differences in interaction of access moves with inheritance    and interacting of access modes with polymorphism.    Also it tests a very peculiar case when a method may overwrite two other methods      at the same time, and I didn't found the answer in JLS to this case yet.2.1. Test that the same class hierarchy may contain multiple method chains    with the same signature, but with package mode and in different packages.    - a.A  public f, less specific.    - a.A: package f    - b.B: package f    - a.C: package f    - C < B < A    - call: ((A)C).f, ((B)C).f, ((C)C).f , both from package a and from package b      (where applicable).2.2.  Test that the same class hierarchy may contain multiple method chains    with the same signature, but with package mode and in different packages.    Also, when a method in a chain extends it's access mode to protected, this    does not affect the method chain above (in the superclasses).    - a.A  public f, less specific.    - a.A: package f    - b.B: package f    - a.C: protected f    - C < B < A    - call: ((A)C).f, ((B)C).f, ((C)C).f , both from package a and from package b      (where applicable).2.3. Test that three methods may form one single overwriting chain,      with first method being package mode, and the remaining two - protected.    - a.A  public f, less specific.    - a.A: package f    - a.B: protected f    - b.C: protected f    - C < B < A    - call: ((A)C).f, ((B)C).f, ((C)C).f , both from package a and from package b      (where applicable).2.4. Test whetner a method may extend two methods at the same time, one package and one protected.    It is not clear whether this is really possible.    - a.A  public f, less specific.    - a.A: package f    - b.B: protected f    - a.C: protected f    - C < B < A    - call: ((A)C).f, ((B)C).f, ((C)C).f , both from package a and from package b      (where applicable).  This is the most interesting test. I'm not sure whether this test will compile.  It seems that C.f() overwrites both A.f() and B.f() at the same time.  todo: Question: What will happen if from method C.f() we'll call super.f() ?      If both base methods are overridden at the same time, we have a strange ambiguity.      This possibility is a proof that this case should be prohibited.todo later:Part 3. Tests for getAccessMode(), but for constructors. Will be implemented once we'll have the ability to call from  a constructor another constructor of the same class.