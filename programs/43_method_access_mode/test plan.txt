Runtime semantics of access mode in the context of overriding and overloading.1. Access mode semantics in the context of method overriding.  Testing that a class may have multiple methods  with the same signature but not in an overloading relation,  due to private/package access mode.  - a.A:    - private f()    - package g()    - protected h()    - public k()    - public call() - calls all four other methods.  - a.B < A:    - public f()    - public g()    - public h()    - public k()  - b.C < A:    - public f()    - public g()    - public h()    - public k()  - A aa, ab, ac. On all three refs execute call().2. Access mode semantics in the context of method overriding.  Non-public access modes in base class, non-public access modes in derived class,    all allowed combinations in two contexts derived in the same package    and derived on other package.  - a.A:    - private f11()    - private f12()    - private f13()    - package g21()    - package g22()    - package g23()    - protected h33()    - public call() - calls all the methods.  - a.B < A:    - private f11()    - package f12()    - protected f13()    - package g22()    - protected g23()    - protected h33()  - b.C < A:    - private f11()    - package f12()    - protected f13()    - private g21()    - package g22()    - protected g23()    - protected h33()  - A ab, ac. On all three refs execute call().3. Access mode semantics in the context of method overloading. Test of accessibility.  Multiple overloaded methods, all potentially applicable, with more specific versions having a  more restricted access specifier. In all contexts, the most restricted accessible method will  be called.  - a.A:    - private f(byte)    - package f(short)    - protected f(int)    - public f(long)    - public call(a.A): calls f(byte) on a.A object    - public call(): calls f(byte) locally  - a.B:    - public call(a.A): calls f(byte) on a.A object  - b.C < A:    - public call(a.A): calls f(byte) on a.A object    - public call(): calls f(byte) locally  - b.D:    - public call(a.A): calls f(byte) on a.A object    - call all six call() methods.4. Same as test 3 but now we have three overloaded methods  in A instead of one: f(), g(), and h(). This is an extensive test of access modes  accessibility.  The difference is the access mode of the most specific version:    - f(byte) is package    - g(byte) is protected    - h(byte) is publicAll methods with all versions are the following:    - private f(short)    - package f(byte)    - protected f(int)    - public f(long)    - private g(short)    - package g(int)    - protected g(byte)    - public g(long)    - private h(short)    - package h(int)    - protected h(long)    - public h(byte)todo:5. Protected access mode and overloading.  Test that protected methods cannot be called using a qualified expression line a.f(),  even if a is the same object as this. Base and derived classes are necessary in  different packages, so that protected mode cannot be interpreted ans package.  Case when protected can be interpreted as package is covered in the test 4.    The program should test 3 cases:    - this.f() - ok    - a.f(), a =/= this - protected is inaccessible.    - a.f(), a == this - protected is inaccessible.6. Test getAccessMode() function.  - one method attribute - access mode, for public, protected, private.  - two method attributes, an access mode and final, access mode is first  - two method attributes, an access mode and final, access mode is the second  - no method attributes  - just one attribute - finaltodo:7. Test 5, but for constructors. Will be implemented once we'll have the ability to call from  a constructor another constructor of the same class.