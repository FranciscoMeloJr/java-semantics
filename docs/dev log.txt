Chapter 1. Main class detection


1. First we need to define precise semantics for main method. Right now
  main class is any class containing a static method.

1.1 We need to define main class to be the class having the exact main method:
    public static void main(String[]), with semantically equivalent variations.

1.2 Main method should be called without instantiating the class, in a proper static context.
  Right now it is called as: new MainClass().main(new String[0])
  We should call it as: MainClass.main(new String[0])

It seems that the solution is much easier: we simply have to pass to the configuration the main class name
  from the command line.


Chapter 2. Static methods


1. Extend methodClosure to have one more element - ContextType, of type staticCT or instanceCT.
  This value will be stored into closure during process-classes phase.
  For now, all static method calls except class-qualified should work in the basic case.
  (They worked before step 1 too, by simply ignoring static modifier)
2. Resolve class-qualified static method calls, like A.f().
  In such expressions A is wrapped in a label 'AmbName. We need to extends 'AmbName so that
  it may be resolved into one of three - local var, field or class name. In first two cases
  'AmbName is simply converted into 'ExprName (we will improve this behaviour later)
  In the third case it is converted into 'TypeName. Precedence is in the described order
  as for name resolution procedure, JLS $6.
  For this, we will do the following:

2.1 Add one more rule to lookupField function, for the case when the field is not found:

rule lookupField(<envStack>.  </envStack>, _) => noValue

2.2 Now, a result of a lookupField may be either a lookup(L)::T or noValue
2.3 We will add a new syntactic construct ?? which will allow us to implement chain of responsibility
  pattern: K1 ?? K2 will evaluate K1 first, if the result is other than noValue, it will keep it,
  otherwise it will rewrite into K2 and ultimately evaluate into the result of K2.
  This pattern could be used in other places of semantics as well, but we'll keep it here for now:

syntax KResult ::= "noValue"

syntax K ::= K "??" K [strict(1)]

rule [chainOfResponsibility1]:
    KR:KResult ?? _ => KR
when KR =/=K noValue

rule [chainOfResponsibility2]:
    noValue ?? K => K

2.4 Now we an use ?? construct to extend the semantics of AmbName (rule updated):

rule [AmbName]:
    'AmbName(Ks:List{K}) => 'ExprName(Ks) ?? 'TypeName(Ks)
        [structural, anywhere]

2.5 Implement method call starting from a term like
    methodNameImpl(class Class:Id, Name:Id, IsQ:Bool)
  For this, both lookupSignature and lookupMethod functions are applicable.
  (lookupMethod will be called with just one class as second argument - the target class)
  We can also implemente conversion form methodNameImpl to lookupMethodData,
    just OL will be empty.

2.5.1. We add one more rule for conversion methodNameImpl => lookupMethodData
  for class-qualified method calls:

rule [MethodNameStatic]:
    <k>
      methodNameImpl(class Class:Id, Name:Id, IsQ:Bool)
      => lookupMethodData(noValue, Class, Name,
          <envStack> ListItem((Class, <env> . </env>)) </envStack>, IsQ)
      ...
    </k>
    <isQualified> _ => IsQ </isQualified>

2.5.2.
We will add one more rule to actual static method invocation, adapted from [invokeImplInstance]:

rule [invokeImplStatic]:
    <k>
      invokeImpl(
        methodClosure(Class:Id, 'ListWrap(Params:List{K}), staticCT, Body:K)
            :: methodType(_, _, T:Type),
        _,
        'ListWrap(ParamValues:List{K})
      ) ~> K:K
       => bindto Params, ParamValues ~> Body ~> 'Return('None(.List{K}))
    </k>
    <control>
      <stack>
        . =>  ListItem((return,.K,.K,K, Env,
                  (
                    <crntObj> OldObj </crntObj>
                    <return> OldT </return>
                    C
                  )
              ))
        ...
      </stack>
      <crntObj>
        OldObj:Bag
        => <crntClass> Class </crntClass>
           <envStack> .List </envStack>
           <location> noValue </location>
      </crntObj>
      <return> OldT:Type => T </return>
      C:Bag
    </control>
    <env> Env:Map => . </env>
when isKResult(ParamValues)

2.5.3:
    We have to add two more rules in field lookup section, to make possible evaluation of 'This,
    when we are in a static context (required as part of new 'AmbName semantics):

rule [ThisNoValue]:
    <k>
      'This(.List{K}) => noValue
      ...
    </k>
    <location> noValue </location>

rule [ExprNameNoValue]:
    'ExprName( noValue,, X:Id ) => noValue    [structural]

With this steps, static method call qualified by class works.

3. We need to extend semantics for unqualified method name,
  in order to interpret it in static context. We update the existing rule for
  method name unqualified to:

rule [MethodNameUnqInstanceCT]:
    <k>
      'MethodName(Name:Id) => 'MethodName('This(.List{K}),, Name)
      ...
    </k>
    <location> _:Int </location>

and add a new rule:

rule [MethodNameUnqStaticCT]:
    <k>
      'MethodName(Name:Id) => 'MethodName('TypeName(Class),, Name)
      ...
    </k>
    <crntClass> Class:Id </crntClass>
    <location> noValue </location>

4. Right now just three tests fail, all of them seem related to no overwriting/hiding.
Another helper method is required to extract ContextType from a method closure:

syntax K ::= "getMethodContextType" "(" TypedVal ")" [function, strict(1)]
rule getMethodContextType( methodClosure(_, _, CT:ContextType, _) :: _ ) => CT [anywhere]
rule getMethodContextType( constrClosure(_,_,_,_) :: _ ) => instanceCT [anywhere]

5. Finally we can use the function above to extend one of lookupMethod rules.
  More precisely, replacement of one version of suitable method closure by other one during
  method lookup should happen only in instance context. The new rule is:

rule [lookupMethodOtherCandidates]:
    lookupMethod(
      sig(Name:Id, types(SigTL:List{K})),
      (_,, LayerClass:Id),
      (sig(Name, types(SigTL)) |-> TV:TypedVal => .) _:Map,
      MCClosure:RawVal :: methodType(Acc:AccessMode, SigTL, T:Type)
      => 'If(
            'LazyAnd(
              (getMethodContextType(MCClosure :: methodType(Acc, SigTL, T)) ==K instanceCT)::bool,,
              isAccessibleForOverwriting(
                getMethConsClosureClass(MCClosure), Acc, LayerClass, getMethodAccessMode(TV)
              )
            ),,
            TV,,
            MCClosure :: methodType(Acc, SigTL, T)
          )
    )

With this rule, 17 tests from 18 passed. The only test left is related to protected mode.

6. In order to pass the final test we need to make static protected methods accessible
  for any calling expression type, not just this.f() or super.f() as for instance methods.
  For this we will extend the function isAccessible to take three arguments instead of two:

syntax K ::= "isAccessible" "(" Id ","          //the method class
                                AccessMode ","  //the method access mode
                                K               //evaluates to ContextType
                            ")"
        [strict(2)]

  Now we should extends isaccessible implementation. All rules have to be changed to adapt
  the new argument. Most notable is the rule for protected that uses the argument:

rule [isAccessibleProtected]:
    <k>
      isAccessible(Class:Id, protected, CT:ContextType)
      => 'LazyOr(
            'LazyAnd(
              'LazyOr((CT ==K staticCT)::bool,, 'Not(isQualifiedMethodCall)),,
              subtype(class CurrentClass, class Class)
            ),,
            isAccessible(Class, package, CT)
      )
      ...
    </k>
    <crntClass> CurrentClass:Id </crntClass>

Now we have to change the two places where isAccessible is used, to pass the new argument.

With this changes all tests for static methods passed.

Final statistics:
  Syntax constructs added: 5
  Syntax constructs updated: 5
  Rules added: 13
  Rules updated: 18
  Rules deleted: 1


Chapter 3. Static fields.

1. In order to implement static fields, we add a cell to the configuration:
  - <staticEnv>
    <staticEnv> is the environment of static fields of a class. It contains just the fields
  declared in this class, not those inherited from superclasses.

2. We add a side condition to the rule [FieldDecToLocalVarDec], so that the
  rule is only applied to instanceCT fields:

rule [FieldDecToLocalVarDec]:
    <k> 'FieldDec(Modifiers:K,, TypeK:K,, 'ListWrap('VarDec(X:Id))) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <fieldDecs>
      'ListWrap(_,, ( .List{K} => 'LocalVarDec(TypeK,, 'ListWrap('VarDec(X,, default(TypeK)))) ))
    </fieldDecs>
when
    getContextType(Modifiers) ==K instanceCT

3. We add a somewhat similar rule for static fields:

rule [StaticFieldDecToLocalVarDec]:
    <k> 'FieldDec(Modifiers:K,, T:Type,, 'ListWrap('VarDec(X:Id))) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <staticEnv> Env:Map => Env[L/X] </staticEnv>
    <store>... . => L |-> default(T) ...</store>
    <nextLoc> L:Int => L +Int 1 </nextLoc>
when
    getContextType(Modifiers) ==K staticCT

4. Processing of class-qualified variable references, both
  rvalue and lvalue:

  7 rules in java-classes.k just after
syntax K ::= lookupStaticField ...

  With those rules we can access static fields for both reading and writing through
  class-qualified expressions.

5. Accessing static fields through unqualified expressions.

First, we have to change the rule [ExprNameMember] so that a simple var name
  will be looked up among instance members, and if not found - among static members.
  This semantics is not correct in all cases, and tests involving field access modes
  should reveal this. but it should work for existing tests.

5.1

rule [ExprNameMember]:
    <k>
      'ExprName(X:Id) => 'ExprName( 'This(.List{K}),, X ) ?? 'ExprName(class Class,, X )
      ...
    </k>
    <env> Env:Map </env>
    <crntClass> Class:Id </crntClass>
when
    notBool( (X in keys(Env)) orBool (Id2String(X) ==String "System") )

5.2. A similar change in the rule [lvalueExprNameMember]

6. Now, in order to support accessing static fields through this, super, unqualified
  and object-qualified expressions, we will add static fields to the instance-environment
  of every object.
    For this we have to update [create] rule and add copying of the static environment into
  the instance environment of the class being created:

rule [create]:
    <k>
      create(Class:Id)
      => create(BaseClassK) ~> setCrntClass(Class) ~> env(StaticEnv) ~> S ~> addEnvLayer
      ...
    </k>
    <className> Class </className>
    <extends> BaseClassK:K </extends>
    <fieldDecs> S:K </fieldDecs>
    <staticEnv> StaticEnv:Map </staticEnv>

Now 9 tests out of 10 for static fields pass. The failing test is:
  - Static fields default values.

Chapter 4. Static initialization.

1. We have to add two new cells to the <class>:
  - <staticInit> - static initializers, including field initializers
  - <staticInitDone> false </staticInitDone> - whether static initialization was performed
  for this class. Is required to ensure that each class is initialized only once.

2. Populate the cell <staticInit> during process-classes phase.

First we need to change field init desugar to limit it to instance fields only:

rule [FieldDecInstanceInitDesugar]:
    'FieldDec(Modifiers:K,, TypeK:K,, 'ListWrap('VarDec(X:Id,,(InitExp:K => .List{K})) ))
    ~> (. => 'InstanceInit('ExprStm('Assign('ExprName(X),, InitExp))))
when
            (getKLabel(InitExp) =/=KLabel 'ArrayInit)
    andBool (getContextType(Modifiers) ==K instanceCT)

Second we add rules similar to field init desugar and instance init saving,
  but for static field initializers / static initializers:

rule [StaticFieldDecToLocalVarDec]:
    <k> 'FieldDec(Modifiers:K,, T:Type,, 'ListWrap('VarDec(X:Id))) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <staticEnv> Env:Map => Env[L/X] </staticEnv>
    <store>... . => L |-> default(T) ...</store>
    <nextLoc> L:Int => L +Int 1 </nextLoc>
when
    getContextType(Modifiers) ==K staticCT

rule [StaticInitSave]:
    <k> 'StaticInit(K:K) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <staticInit>... . => K </staticInit>

3. Trigger static init.

3.1. During static method call. For this we change the rule [invokeImplStatic] and add a call to
  staticInit(Class) in the
  right-hand side of the rewriting inside <k> cell. For now we will trigger static init
  just for static method calls.

3.2. During static field class-qualified read. For this we add an invocation to staticInit()
  in the rule [lookupStaticField]. Note that only class-qualified field access may trigger static
  init. Object-qualified or unqualified access would have triggered it already through
  object instantiation or static method call.

3.3 During static field class-qualified read. We update the rule [lvalueLookupStaticField].
3.4 For object instantiation we update [NewInstance].

4. Implement staticInit(Class) term. For this we created a whole new module: JAVA-STATIC-INIT.

  For now 14 tests of 16 for static fields pass. Also all tests related to class static init
  trigger also pass. The only failing tests are related to ExceptionInInitializerError.

5. Semantics for ExceptionInInitializerError. Now we wrapped call to static init into a try-catch,
  in the rule [staticInit]. All tests for static init and class init trigger pass.

Chapter packages.

First we need a refactoring so that all class types in the program will be represented as
fully qualified class names. More precisely:
  - 'TypeName(X) - X may be simple name
  - class X - X is fully qualified class name, also an Id.
  For this, each class will have three cells:
  <className> - fully qualified class name, Id
  <package> - package name, String
  <classSimpleName> - simple class name, Id

Implementation:

1.ok. Save class type, package and class simple name during process-comp-units.
2.ok. (temporary) Change the whole definition so that types are resolved to their simple names,
  referrign to the cell <classSimpleName>.
3.ok. Change again the whole definition. Now instead of referring an Id inisde <classSimpleName>,
  refer to ClassType inside <classType>.
  In order to make things work for now, <classType> cell will contain simple class references,
  like class Exception. This refactoring will assure that the content of <classType>
    is of type classType, not Id.
4.ok. Change the rule [TypeName] to be non-anywhere, and to require heating.
  Change all the locations in the definition to perform proper heating of 'TypeName terms.

5.ok. Mock implementation of packages, v1: all type names are resolved into simple names.
  Fully qualified names are also transformed into simple names, by ignoring their qualifier.

6.ok. Correct representation of classes as fully qualified names.
  The first fully qualified name that match the simple name in <classes> cell is used.
  Imports are ignored. Fully qualified names in the code are correctly resolved.

    For this a new cell was added to the configuration : <topLevelNamesMap>
  The cell is of type:
  Map[packageId ->Map[SimpleClassName -> ClassType]].
    This cell is used to resolve simple names into fully qualified names.
  It is populated at the very first step of program execution
  - process-top-level-names, before process-comp-units.
  Both preprocessing steps take as arguments the whole program as kast.
    As a result all tests related to fully qualified class names pass.

    A curious problem arose with this implementation:
  If a base class and a derived class have the same name, base constructor will never be called.
  Instead, the derived constructor will be called, causing an infinite loop.
  The solution is to call the base constructor using 'SuperMethod(...) term
  instead of 'Method(MethodName(...)).

7.ok. Import declarations.
    For this, two more cells are added to the configuration.
  First one is <compUnitImports> - a Map[SimpleName->FullName] of all classes accessible
  by simple name in a particular CU. The cell is computed during parsing of import
  declarations, in process-comp-units phase. The rules for computing <compUnitImports>
  are separated into a new file - java-process-imports.k.
    Second cell is <imports> inside <class>. It contains
  a copy of <compUnitImports> specific for the cmpilation unit of each particular class.

8.ok Class access modes.
    Now import on demand declarations should import public classes.
  Since import declarations are resolved before class declarations,
  class access mode is processed in the very first phase - ProcessTopLevelNamesPhase.
    Class access mode information is in a new cell:
  <classesToAccessModes> of type Map[ClassType -> AccessMode].

Static inner classes.

1.ok.  We have to change the name and meaning of the cell <topLevelNamesMap> into <typeNamesMap>
  - this cell will store not only top-level names, but inner type names as well.
  This is required during ProcessCompUnitsPhase, to correctly resolve extends/implements
  clauses containing inner types.
    As a result, the phase ProcessTopLevelNamesPhase is renamed into ProcessTypeNamesPhase.
  Also the module is renamed. The phase is updated to process inner type names as well.

2.ok. Similarly, we need to update ProcessCompUnitsPhase, so that a proper <class>
  cell is created for each inner class.

In order to distinguish between 'ClassDec here and 'ClassDec in process-classes, we need to
  wrap K terms containing classes into a wrapper tag.

3. In the same manner, we need to update ProcessClassesPhase, so that each inner class
could process its extends/implements and members.

The great dilemma of <imports> inside inner classes.

Apparently the phase ProcessCompUnits for inner classes should be executed after the phase ProcessClasses
for the outer class. Otherwise inner classes won't have the right <imports> content,
and won't be able to see inner classes inherited by the outer class by simple name.


  Steps of processTypeDecs(Class) (ProcessCompUnits):
1. Resolve extends and implements classes
2. Save <class> cell.
3. Save <imports> inside <class>. ImportsMap(Class) = ImportsMap of outer + types defined in Class.
4. processTypeDecs(Inner classes)

  Steps of processTypeWithDepends(Class) (ProcessClasses):
1. processTypeWithDepends(BaseClass)
2. processTypeWithDepends(base interfaces)
3. Compute transitive closure of implemented interfaces.
4. Inherit the methods of base interfaces.
5. Inherit the methods of base class.
6. Inherit interface fields.
7. Process this class declarations.

  The problem is that <imports> map computed on phase processTypeDecs step 3
don't contain types inherited from the base class. It should be computed
somehow after phase processTypeWithDepends step 5, and imports
should be computed at the same time as inherited methods (approximately).

Restrictions on the order of computation:
Relevant steps of processing a class:
  - base (meaning extends/implements) - resolving the type of base classes.
  - transitive closure
  - imports

Restrictions:
    ( > means computed later).
1. transitive_closure(X) > base(X), by definition of transitive closure.
2. base(X) > imports(outer), so that extends/implements(X) may use classes from
    outer by simple name.
3. imports(X) > imports(outer) - simple class names within X include simple class names within outer.
4. imports(X) > imports(transitive_closure(X)) - simple name within X include simple names
  inherited directly or indirectly from base classes. <=>
  4.1. imports(X) > imports(base(X))
  4.2. imports(X) > transitive_closure(X)

As a result we have to check the following relations before computing imports(X):
R1. imports(outer) < imports(X).
R2. imports(base) < imports(X).
R3. transitive_closure(X) < imports(X).

The two tree-relations: nesting and inheritance, when combined, define an topological graph.
the order in which <imports> is computed should be in agreement with the partial order defined
by this graph. The graph is guaranteed to be topological according to JLS, definition
of dependent classes( JLS3 $8.1.4 p185).

We should process classes in the following order (supposedly):

  Steps of processTypeDecs(Class) (ProcessCompUnits):
1. Resolve extends and implements classes
2. processTypeDecs(BaseClass) (if not processed)
3. processTypeDecs(base interfaces) (if not processed)
4. Compute transitive closure of implemented interfaces.
5. Save <class> cell.
6. Compute <imports> inside <class>. ImportsMap(Class) = ImportsMap of outer + types defined in Class.
7. processTypeDecs(Inner classes)

That's not possible. In order to process classes in the order of their dependency graph,
we need to have all classes - both top-level and inner, available in one single big map.
(or maybe not?)

We need to process something for the top-level classes first, and to leave the inference engine
to process the rest.

It is clear that we cannot process top-level classes first, and inner casses next. Also there is no order
in which CU's could be processed entirely one by one. We could have several CUs cyclically
dependent of each other.

A question is still open: can we process top-level classes entirely with their inner classes,
  triggering here and there processing of dependent top-level classes? Answer: NO:

Important limitation: A request to process an inner class out-of-order cannot be reduced to
the request of processing it's top-level class with all its content. Example:
A{InA < B.InB1}, B < A{ InB1, InB2 < InA}
Correct order of processing: A, B, InB1, InA, InB2.
B, InB1, InB2 cannot be processed entirely, without processing InA between InB1 and InB2.

Apparently, we need to implement the following algorithm:

ProcessCompUnitsPhase:
  For each CU:
1. Process imports. Save them in a separate <compUnitImports> cell.
2. For each class save the <class> cell with just the following:
  - <classType> - since we process CU content recursively, should be available
  - <enclosingClass>
  - <imports> - just for top-level classes, imports are taken from the <compUnitImports>.
              For inner classes this cell is still empty.
  - <classDec> - content of its 'ClassDec term. When this term is non-empty
    then the class has not been preprocessed yet.
  This way we will have fast access to the declaration of a class, and will be able to
  process declarations in a less-restricted order. Do this by recursively processing the content
  of the current CU.

ProcessClassesPhase:
3. For each CU, for each top-level class X, processTypeWithDepends(X).
4. processTypeWithDepends(X) =>
    processTypeWithDepends(outer)
    ~> resolveBase(X) - will transform <extendsSimple> into <extends> and <implementsSimple> into <implements>
    ~> processBaseWithDepends(X)
    ~> processType(X)
when unprocessed(X)
5. processBaseWithDepends(X) => processTypeWithDepends(base(X))
6. processType(X) =>
    computeImplTrans(X)
    ~> computeImports(X)
    ~> processTypesWithDepends(inner(X))
when unprocessed(X)

The next phase will be called ProcessMembersPhase.

First we will do a refactoring which will enable us to define the final ProcessCompUnitsPhase,
and to implement the ProcessClassesPhase in a way maximally compatible with the current implementation.

We need to write down the plan for the following three phases of implementation:
  1. Current implementation.
  2. After refactoring. correct ProcessCompUnitsPhase,
    ProcessClassesPhase doing the remaining job of the old ProcessCompUnitsPhase.
  3. Final implementation.

  Also I need to write a technical report on this matter, necessarily.

Another important property: dependency relation in JLS
  is not the same as inheritance + enclosing relation we use in semantics,
  but they both lead to th e same semantic restrictions. We need to prove this,
  if possible.

        ALG 1. CURRENT IMPLEMENTATION OF PREPROCESSING PHASES

Part 1. ProcessCompUnitsPhase.

  For each CompUnit separately:
1. Process import decs. Build <compUnitImports>.
  For each class in CompUnit separately:
2. Desugar noExtends, noImplements
3. Resolve extends/implements clauses by context rules.
4. Add a default constructor to all classes.
5. Save the following content:
    <class>
      <classType> getClassType(Pack, SimpleClass) </classType>
      <extends> BaseClass </extends>
      <implements> TypeSet </implements>
      <declarations> CBody </declarations>
      <metaType> MetaT </metaType>
      <enclosingClass> OuterClass </enclosingClass>
      ...
    </class>

6. Process imports for the saved class - the <imports> cell.
7. Process inner classes.

  Since we do not know whether classes in extends/implements clauses were processed,
    we cannot import inner types from those classes, and as a result <imports> content generated
    by this algorithm will be incomplete.

Part 2. ProcessClassesPhase:
8. For each class in <classes>, processTypeWithDepends(class)
  - processTypeWithDepends(class) => .K if class already processed.
9. processTypeWithDepends(C) => processTypeWithDepends(extends class, implements classes)
  ~> processType(C)
  processType(C):
10. Mark C as processed
11. computeImplTrans(base class and interfaces)
12. tryInherit(interfaces)            (inherit methods)
13. tryInherit(Object), if interface  (inherit methods)
14. tryInherit(BaseClass)             (inherit methods)
15. inheritInterfaceFields
16. process members

        ALG 2. VERSION 1 OF DESIRED PREPROCESSING PHASES

Part 1. ProcessCompUnitsPhase:
  For each CompUnit separately:
1. Process import decs. Build <compUnitImports>.
  For each class in CompUnit separately:

2. For each class save the <class> cell with just the following:
  - <classType> - since we process CU content recursively, should be available
  - <enclosingClass>
  - <imports> - just for top-level classes, imports are taken from the <compUnitImports>.
              For inner classes this cell is still empty.
  - <classDec> - content of its 'ClassDec term. When this term is non-empty
    then the class has not been preprocessed yet.
  This way we will have fast access to the declaration of a class, and will be able to
  process declarations in a less-restricted order. Do this by recursively processing the content
  of the current CU.

Part 2. ProcessClassDecsPhase:
3. For each CU, for each top-level class X, processTypeWithDepends(X).
4. processTypeWithDepends(X) =>
    processTypeWithDepends(outer)
    ~> resolveBase(X) - will compute <extends> and <implements> cells for X.
    ~> processBaseWithDepends(X)
    ~> processType(X)
when unprocessed(X)
5. resolveBase(X): desugar noExtends, noImplements
6. resolveBase(X): Resolve extends/implements clauses by context rules.
7. resolveBase(X): save <extends> and <implements> cells.
8. processBaseWithDepends(X) => processTypeWithDepends(base(X))
9. processType(X) =>
    addDefaultConstructor(X)
    ~> computeImplTrans(X)
    ~> computeImports(X)
    ~> processTypesWithDepends(inner(X))
when unprocessed(X)
10. addDefaultConstructor(X)
11. computeImplTrans(X)
12. computeImports(X)
13. processTypesWithDepends(inner(X))

Part 3. ProcessClassesPhase:
    For each class C in <classes>:
14. tryInherit(interfaces)            (inherit methods)
15. tryInherit(Object), if interface  (inherit methods)
16. tryInherit(BaseClass)             (inherit methods)
17. inheritInterfaceFields
18. process members

        ALG 3. PREPROCESSING PHASES AFTER FIRST REFACTORING - DESIRED PHASE 1.

Part 1. ProcessCompUnitsPhase:
  For each CompUnit separately:
1. Process import decs. Build <compUnitImports>.

  For each class C in CompUnit separately:
2. For each class save the <class> cell with just the following:
  - <classType> - since we process CU content recursively, should be available
  - <enclosingClass>
  - <classDec> - content of its 'ClassDec term. When this term is non-empty
      then the class has not been preprocessed yet.
  - <imports> - just for top-level classes, imports are taken from the <compUnitImports>.
              For inner classes this cell is still empty.

3. Process inner classes of C.

  This way we will have fast access to the declaration of a class, and will be able to
process declarations in a less-restricted order.

Part 2. ProcessClassDecsPhase.

  For each class in <classes> separately:
4. Desugar noExtends, noImplements
5. Resolve extends/implements clauses by context rules.
6. Add a default constructor to all classes.
7. Save the following content:
    <class>
      <extends> BaseClass </extends>
      <implements> TypeSet </implements>
      <declarations> CBody </declarations>
      ...
    </class>

8. Process imports for the saved class - the <imports> cell.
9. Process inner classes.

  Since we do not know whether classes in extends/implements clauses were processed,
    we cannot import inner types from those classes, and as a result <imports> content generated
    by this algorithm will be incomplete.

Part 3. ProcessClassesPhase:
10. For each class in <classes>, processTypeWithDepends(class)
  - processTypeWithDepends(class) => .K if class already processed.
11. processTypeWithDepends(C) => processTypeWithDepends(extends class, implements classes)
  ~> processType(C)
  processType(C):
12. Mark C as processed
13. computeImplTrans(base class and interfaces)
14. tryInherit(interfaces)            (inherit methods)
15. tryInherit(Object), if interface  (inherit methods)
16. tryInherit(BaseClass)             (inherit methods)
17. inheritInterfaceFields
18. process members

    It seems that this refactoring consists from the following:
1. Separate the old ProcessCompUnitsPhase into two phases -
  new ProcessCompUnitsPhase and new ProcessClassDecsPhase.
2. Save the initial content of <class> cell after first step, recursively.
3. Starting from step 3, classes are taked from processing from their <classes>
  cell, not from raw CompUnits.

Now inheritance of inner types is fully implemented.
