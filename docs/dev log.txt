Chapter 1. Main class detection


1. First we need to define precise semantics for main method. Right now
  main class is any class containing a static method.

1.1 We need to define main class to be the class having the exact main method:
    public static void main(String[]), with semantically equivalent variations.

1.2 Main method should be called without instantiating the class, in a proper static context.
  Right now it is called as: new MainClass().main(new String[0])
  We should call it as: MainClass.main(new String[0])

It seems that the solution is much easier: we simply have to pass to the configuration the main class name
  from the command line.


Chapter 2. Static methods


1. Extend methodClosure to have one more element - ContextType, of type staticCT or instanceCT.
  This value will be stored into closure during process-classes phase.
  For now, all static method calls except class-qualified should work in the basic case.
  (They worked before step 1 too, by simply ignoring static modifier)
2. Resolve class-qualified static method calls, like A.f().
  In such expressions A is wrapped in a label 'AmbName. We need to extends 'AmbName so that
  it may be resolved into one of three - local var, field or class name. In first two cases
  'AmbName is simply converted into 'ExprName (we will improve this behaviour later)
  In the third case it is converted into 'TypeName. Precedence is in the described order
  as for name resolution procedure, JLS $6.
  For this, we will do the following:

2.1 Add one more rule to lookupField function, for the case when the field is not found:

rule lookupField(<envStack>.  </envStack>, _) => noValue

2.2 Now, a result of a lookupField may be either a lookup(L)::T or noValue
2.3 We will add a new syntactic construct ?? which will allow us to implement chain of responsibility
  pattern: K1 ?? K2 will evaluate K1 first, if the result is other than noValue, it will keep it,
  otherwise it will rewrite into K2 and ultimately evaluate into the result of K2.
  This pattern could be used in other places of semantics as well, but we'll keep it here for now:

syntax KResult ::= "noValue"

syntax K ::= K "??" K [strict(1)]

rule [chainOfResponsibility1]:
    KR:KResult ?? _ => KR
when KR =/=K noValue

rule [chainOfResponsibility2]:
    noValue ?? K => K

2.4 Now we an use ?? construct to extend the semantics of AmbName (rule updated):

rule [AmbName]:
    'AmbName(Ks:List{K}) => 'ExprName(Ks) ?? 'TypeName(Ks)
        [structural, anywhere]

2.5 Implement method call starting from a term like
    methodNameImpl(class Class:Id, Name:Id, IsQ:Bool)
  For this, both lookupSignature and lookupMethod functions are applicable.
  (lookupMethod will be called with just one class as second argument - the target class)
  We can also implemente conversion form methodNameImpl to lookupMethodData,
    just OL will be empty.

2.5.1. We add one more rule for conversion methodNameImpl => lookupMethodData
  for class-qualified method calls:

rule [MethodNameStatic]:
    <k>
      methodNameImpl(class Class:Id, Name:Id, IsQ:Bool)
      => lookupMethodData(noValue, Class, Name,
          <envStack> ListItem((Class, <env> . </env>)) </envStack>, IsQ)
      ...
    </k>
    <isQualified> _ => IsQ </isQualified>

2.5.2.
We will add one more rule to actual static method invocation, adapted from [invokeImplInstance]:

rule [invokeImplStatic]:
    <k>
      invokeImpl(
        methodClosure(Class:Id, 'ListWrap(Params:List{K}), staticCT, Body:K)
            :: methodType(_, _, T:Type),
        _,
        'ListWrap(ParamValues:List{K})
      ) ~> K:K
       => bindto Params, ParamValues ~> Body ~> 'Return('None(.List{K}))
    </k>
    <control>
      <stack>
        . =>  ListItem((return,.K,.K,K, Env,
                  (
                    <crntObj> OldObj </crntObj>
                    <return> OldT </return>
                    C
                  )
              ))
        ...
      </stack>
      <crntObj>
        OldObj:Bag
        => <crntClass> Class </crntClass>
           <envStack> .List </envStack>
           <location> noValue </location>
      </crntObj>
      <return> OldT:Type => T </return>
      C:Bag
    </control>
    <env> Env:Map => . </env>
when isKResult(ParamValues)

2.5.3:
    We have to add two more rules in field lookup section, to make possible evaluation of 'This,
    when we are in a static context (required as part of new 'AmbName semantics):

rule [ThisNoValue]:
    <k>
      'This(.List{K}) => noValue
      ...
    </k>
    <location> noValue </location>

rule [ExprNameNoValue]:
    'ExprName( noValue,, X:Id ) => noValue    [structural]

With this steps, static method call qualified by class works.

3. We need to extend semantics for unqualified method name,
  in order to interpret it in static context. We update the existing rule for
  method name unqualified to:

rule [MethodNameUnqInstanceCT]:
    <k>
      'MethodName(Name:Id) => 'MethodName('This(.List{K}),, Name)
      ...
    </k>
    <location> _:Int </location>

and add a new rule:

rule [MethodNameUnqStaticCT]:
    <k>
      'MethodName(Name:Id) => 'MethodName('TypeName(Class),, Name)
      ...
    </k>
    <crntClass> Class:Id </crntClass>
    <location> noValue </location>

4. Right now just three tests fail, all of them seem related to no overwriting/hiding.
Another helper method is required to extract ContextType from a method closure:

syntax K ::= "getMethodContextType" "(" TypedVal ")" [function, strict(1)]
rule getMethodContextType( methodClosure(_, _, CT:ContextType, _) :: _ ) => CT [anywhere]
rule getMethodContextType( constrClosure(_,_,_,_) :: _ ) => instanceCT [anywhere]

5. Finally we can use the function above to extend one of lookupMethod rules.
  More precisely, replacement of one version of suitable method closure by other one during
  method lookup should happen only in instance context. The new rule is:

rule [lookupMethodOtherCandidates]:
    lookupMethod(
      sig(Name:Id, types(SigTL:List{K})),
      (_,, LayerClass:Id),
      (sig(Name, types(SigTL)) |-> TV:TypedVal => .) _:Map,
      MCClosure:RawVal :: methodType(Acc:AccessMode, SigTL, T:Type)
      => 'If(
            'LazyAnd(
              (getMethodContextType(MCClosure :: methodType(Acc, SigTL, T)) ==K instanceCT)::bool,,
              isAccessibleForOverwriting(
                getMethConsClosureClass(MCClosure), Acc, LayerClass, getMethodAccessMode(TV)
              )
            ),,
            TV,,
            MCClosure :: methodType(Acc, SigTL, T)
          )
    )

With this rule, 17 tests from 18 passed. The only test left is related to protected mode.

6. In order to pass the final test we need to make static protected methods accessible
  for any calling expression type, not just this.f() or super.f() as for instance methods.
  For this we will extend the function isAccessible to take three arguments instead of two:

syntax K ::= "isAccessible" "(" Id ","          //the method class
                                AccessMode ","  //the method access mode
                                K               //evaluates to ContextType
                            ")"
        [strict(2)]

  Now we should extends isaccessible implementation. All rules have to be changed to adapt
  the new argument. Most notable is the rule for protected that uses the argument:

rule [isAccessibleProtected]:
    <k>
      isAccessible(Class:Id, protected, CT:ContextType)
      => 'LazyOr(
            'LazyAnd(
              'LazyOr((CT ==K staticCT)::bool,, 'Not(isQualifiedMethodCall)),,
              subtype(class CurrentClass, class Class)
            ),,
            isAccessible(Class, package, CT)
      )
      ...
    </k>
    <crntClass> CurrentClass:Id </crntClass>

Now we have to change the two places where isAccessible is used, to pass the new argument.

With this changes all tests for static methods passed.

Final statistics:
  Syntax constructs added: 5
  Syntax constructs updated: 5
  Rules added: 13
  Rules updated: 18
  Rules deleted: 1


Chapter 3. Static fields.

1. In order to implement static fields, we add a cell to the configuration:
  - <staticEnv>
    <staticEnv> is the environment of static fields of a class. It contains just the fields
  declared in this class, not those inherited from superclasses.

2. We add a side condition to the rule [FieldDecToLocalVarDec], so that the
  rule is only applied to instanceCT fields:

rule [FieldDecToLocalVarDec]:
    <k> 'FieldDec(Modifiers:K,, TypeK:K,, 'ListWrap('VarDec(X:Id))) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <fieldDecs>
      'ListWrap(_,, ( .List{K} => 'LocalVarDec(TypeK,, 'ListWrap('VarDec(X,, default(TypeK)))) ))
    </fieldDecs>
when
    getContextType(Modifiers) ==K instanceCT

3. We add a somewhat similar rule for static fields:

rule [StaticFieldDecToLocalVarDec]:
    <k> 'FieldDec(Modifiers:K,, T:Type,, 'ListWrap('VarDec(X:Id))) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <staticEnv> Env:Map => Env[L/X] </staticEnv>
    <store>... . => L |-> default(T) ...</store>
    <nextLoc> L:Int => L +Int 1 </nextLoc>
when
    getContextType(Modifiers) ==K staticCT

4. Processing of class-qualified variable references, both
  rvalue and lvalue:

  7 rules in java-classes.k just after
syntax K ::= lookupStaticField ...

  With those rules we can access static fields for both reading and writing through
  class-qualified expressions.

5. Accessing static fields through unqualified expressions.

First, we have to change the rule [ExprNameMember] so that a simple var name
  will be looked up among instance members, and if not found - among static members.
  This semantics is not correct in all cases, and tests involving field access modes
  should reveal this. but it should work for existing tests.

5.1

rule [ExprNameMember]:
    <k>
      'ExprName(X:Id) => 'ExprName( 'This(.List{K}),, X ) ?? 'ExprName(class Class,, X )
      ...
    </k>
    <env> Env:Map </env>
    <crntClass> Class:Id </crntClass>
when
    notBool( (X in keys(Env)) orBool (Id2String(X) ==String "System") )

5.2. A similar change in the rule [lvalueExprNameMember]

6. Now, in order to support accessing static fields through this, super, unqualified
  and object-qualified expressions, we will add static fields to the instance-environment
  of every object.
    For this we have to update [create] rule and add copying of the static environment into
  the instance environment of the class being created:

rule [create]:
    <k>
      create(Class:Id)
      => create(BaseClassK) ~> setCrntClass(Class) ~> env(StaticEnv) ~> S ~> addEnvLayer
      ...
    </k>
    <className> Class </className>
    <extends> BaseClassK:K </extends>
    <fieldDecs> S:K </fieldDecs>
    <staticEnv> StaticEnv:Map </staticEnv>

Now 9 tests out of 10 for static fields pass. The failing test is:
  - Static fields default values.

Chapter 4. Static initialization.

1. We have to add two new cells to the <class>:
  - <staticInit> - static initializers, including field initializers
  - <staticInitDone> false </staticInitDone> - whether static initialization was performed
  for this class. Is required to ensure that each class is initialized only once.

2. Populate the cell <staticInit> during process-classes phase.

First we need to change field init desugar to limit it to instance fields only:

rule [FieldDecInstanceInitDesugar]:
    'FieldDec(Modifiers:K,, TypeK:K,, 'ListWrap('VarDec(X:Id,,(InitExp:K => .List{K})) ))
    ~> (. => 'InstanceInit('ExprStm('Assign('ExprName(X),, InitExp))))
when
            (getKLabel(InitExp) =/=KLabel 'ArrayInit)
    andBool (getContextType(Modifiers) ==K instanceCT)

Second we add rules similar to field init desugar and instance init saving,
  but for static field initializers / static initializers:

rule [StaticFieldDecToLocalVarDec]:
    <k> 'FieldDec(Modifiers:K,, T:Type,, 'ListWrap('VarDec(X:Id))) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <staticEnv> Env:Map => Env[L/X] </staticEnv>
    <store>... . => L |-> default(T) ...</store>
    <nextLoc> L:Int => L +Int 1 </nextLoc>
when
    getContextType(Modifiers) ==K staticCT

rule [StaticInitSave]:
    <k> 'StaticInit(K:K) => . ...</k>
    <cuClass> Class:Id </cuClass>
    <className> Class </className>
    <staticInit>... . => K </staticInit>

3. Trigger static init.

3.1. During static method call. For this we change the rule [invokeImplStatic] and add a call to
  staticInit(Class) in the
  right-hand side of the rewriting inside <k> cell. For now we will trigger static init
  just for static method calls.

3.2. During static field class-qualified read. For this we add an invocation to staticInit()
  in the rule [lookupStaticField]. Note that only class-qualified field access may trigger static
  init. Object-qualified or unqualified access would have triggered it already through
  object instantiation or static method call.

3.3 During static field class-qualified read. We update the rule [lvalueLookupStaticField].
3.4 For object instantiation we update [NewInstance].

4. Implement staticInit(Class) term. For this we created a whole new module: JAVA-STATIC-INIT.

  For now 14 tests of 16 for static fields pass. Also all tests related to class static init
  trigger also pass. The only failing tests are related to ExceptionInInitializerError.

5. Semantics for ExceptionInInitializerError. Now we wrapped call to static init into a try-catch,
  in the rule [staticInit]. All tests for static init and class init trigger pass.

Chapter packages.

First we need a refactoring so that all class types in the program will be represented as
fully qualified class names. More precisely:
  - 'TypeName(X) - X may be simple name
  - class X - X is fully qualified class name, also an Id.
  For this, each class will have three cells:
  <className> - fully qualified class name, Id
  <package> - package name, String
  <classSimpleName> - simple class name, Id

Implementation:

1.ok. Save class type, package and class simple name during process-comp-units.
2.ok. (temporary) Change the whole definition so that types are resolved to their simple names,
  referrign to the cell <classSimpleName>.
3.ok. Change again the whole definition. Now instead of referring an Id inisde <classSimpleName>,
  refer to ClassType inside <classType>.
  In order to make things work for now, <classType> cell will contain simple class references,
  like class Exception. This refactoring will assure that the content of <classType>
    is of type classType, not Id.
4.ok. Change the rule [TypeName] to be non-anywhere, and to require heating.
  Change all the locations in the definition to perform proper heating of 'TypeName terms.

5.ok. Mock implementation of packages, v1: all type names are resolved into simple names.
  Fully qualified names are also transformed into simple names, by ignoring their qualifier.

6.ok. Correct representation of classes as fully qualified names.
  The first fully qualified name that match the simple name in <classes> cell is used.
  Imports are ignored. Fully qualified names in the code are correctly resolved.

    For this a new cell was added to the configuration : <topLevelNamesMap>
  The cell is of type:
  Map[packageId ->Map[SimpleClassName -> ClassType]].
    This cell is used to resolve simple names into fully qualified names.
  It is populated at the very first step of program execution
  - process-top-level-names, before process-comp-units.
  Both preprocessing steps take as arguments the whole program as kast.
    As a result all tests related to fully qualified class names pass.

    A curious problem arose with this implementation:
  If a base class and a derived class have the same name, base constructor will never be called.
  Instead, the derived constructor will be called, causing an infinite loop.
  The solution is to call the base constructor using 'SuperMethod(...) term
  instead of 'Method(MethodName(...)).

7.ok. Import declarations.
    For this, two more cells are added to the configuration.
  First one is <compUnitImports> - a Map[SimpleName->FullName] of all classes accessible
  by simple name in a particular CU. The cell is computed during parsing of import
  declarations, in process-comp-units phase. The rules for computing <compUnitImports>
  are separated into a new file - java-process-imports.k.
    Second cell is <imports> inside <class>. It contains
  a copy of <compUnitImports> specific for the cmpilation unit of each particular class.

8.ok Class access modes.
    Now import on demand declarations should import public classes.
  Since import declarations are resolved before class declarations,
  class access mode is processed in the very first phase - ProcessTopLevelNamesPhase.
    Class access mode information is in a new cell:
  <classesToAccessModes> of type Map[ClassType -> AccessMode].

Static inner classes.

1.ok.  We have to change the name and meaning of the cell <topLevelNamesMap> into <typeNamesMap>
  - this cell will store not only top-level names, but inner type names as well.
  This is required during ProcessCompUnitsPhase, to correctly resolve extends/implements
  clauses containing inner types.
    As a result, the phase ProcessTopLevelNamesPhase is renamed into ProcessTypeNamesPhase.
  Also the module is renamed. The phase is updated to process inner type names as well.

2.ok. Similarly, we need to update ProcessCompUnitsPhase, so that a proper <class>
  cell is created for each inner class.

In order to distinguish between 'ClassDec here and 'ClassDec in process-classes, we need to
  wrap K terms containing classes into a wrapper tag.

3. In the same manner, we need to update ProcessClassesPhase, so that each inner class
could process its extends/implements and members.

Apparently the phase ProcessCompUnits for inner classes should be executed after the phase ProcessClasses
for the outer class. Otherwise inner classes won't have the right <imports> content,
and won't be able to see inner classes inherited by the outer class by simple name.

