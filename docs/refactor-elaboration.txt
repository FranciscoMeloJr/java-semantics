    Plan for the refactoring of semantics inspired by JBook:

  Separation of static and dynamic semantics.
Static semantics should compute anything that traditionally is computed at compile time.
Dynamic semantics should compute just what is computed at runtime. More precisely, we have to
move to the static semantics the following:
  - Deduction of compile-time type for each expression.
  - The right signature on method overloading.
  - Names lookup - resolution of each name into a fully-qualified name,
  or simple name, by case.

  Given that there is some dependence between those steps, we have to perform
those steps in certain order. Moreover, now we have to preprocess statement blocks before executing them -
the content of methods, static and instance initializers.
  So, we have to perform the refactoring in the following four steps:
1.ok. Perform a preprocessing of blocks, that recursively visits each term of the block but leaves it untouched. This will be a new preprocessing step,
  after the preprocessing of classes members.
  It should not be a new global preprocessing. Instead it will be performed for each class after its members have been collected and the class reached the phase MembersProcessedCPP.
  Over this preprocessing we will be able to add certain transformations for certain KLabels.
2. Implement names lookup in static semantics.
2.1.ok Implement elaboration of ExprName(X) into localVar or Field.
    We need the following:
2.1.1.ok. Perform the hollow elaboration left to right in all KLists. This way local vars defined
    in a previous statement will be accessible in the next statement.
2.1.2.ok Create a new environment each time we meet an elab('Block).
  The easiest way to store environments during elaboration is as a stack of sets.
  Each time we enter a new block the new stack will be a copy of the previous stack.
2.1.3.ok Restore the environment each time we leave an elab('Block)
2.1.4.ok Save an entry in the environment each time we declare a var.
2.1.5.ok Do the desugaring of 'ExprName(X) into localVar(X)  if it is in the Env, or Field otherwise.

2.2. Elaborate qualified expression names, no packages yet.
2.2.1.ok. Elaborate This as qualifier.
2.2.2.ok. Elaborate Class as qualifier for static fields.
2.2.3.ok. Elaborate Object ref as qualifier for instance fields.
  Object ref Could be localVar, Field or any complex expression of type Ref.
  In addition to elabRes we have to add another type of elaboration result -
  K ::: T - the elaborated qualifier. K is the original expression,
  T is the type of that expression. Something similar to
  objectClosure, but instead of an object we now have a type.
  Thus, in order to resolve qualifiers we need to resolve expression types
  at elaboration phase.

2.2.4.ok. Move elaboration to a separate preprocessing phase, after all classes
  reached the state MembersProcessedCPP. We need class member declarations
  to be processed in order to proceed with block elaboration.
  Otherwise I might need to access the environment of a class whose members
  were not preprocessed, thus don't have its environment computed yet.

2.3.ok. Elaborate other minor expressions.
2.3.1.ok. Elaborate reference cast.
2.3.2.ok. Elaborate for variable declarations.
2.3.3.ok. Elaborate catch variable declarations.
2.3.4.ok. Eliminate elaboration for .K, Id and Type.
2.3.5.ok. Elaborate super.<field> expressions - semantics doubled at runtime and compile time.

2.4.ok. Use elaboration-phase data for field lookup at runtime.
2.4.1.ok. Static and instance field lookup in classes.
2.4.2.ok. Resolve static fields with instance qualifier.
2.4.3.ok. Resolve fields qualified with a reference to interface.

2.5.ok. Elaborate classes in the presence of packages.
2.6.ok. Elaborate names in the presence of inner classes.
2.7.ok. Refactor methods configuration. Now each method is elaborated in its defining class only.

At this step, all tests except array-related and some conditional-operator-related pass.

3.ok. Implement expression type checking and annotation during elaboration.
3.1.ok. Annotate the type of localVar, fieldLookup, staticFieldLookup terms.
  Also other additional terms required to preserve all the passing tests (as for the end of step 2).
3.2.ok. Annotate the type of all numeric expressions, but remove the type annotation during
  runtime to avoid changing runtime rules.
3.3.ok. Annotate the type of all other expressions, including arrays. The type of method invocation
  will be fake - always noClass. In most cases this will not affect execution - only when method invocation
  is part of a larger expression that requires the type of its children in order to compute its type.

3.4.ok. Preserve expression types at runtime. Now the result type is always taken from the source expression type.
  Same tests as for point 3.2. pass. For this we made massive changes in the whole semantics.
  This commit is annotated as a separate "branch", because it could be reverted soon.
  We have to make the choice described below.

  Now we have to make the following design choice:
v1. Preserve expression types at runtime. Like it is done in point 3.4. Unfortunately point 3.4 leads
  to a lot of changes in the whole semantics - all expressions generated during runtime transformations
  should be typed. Also we cannot use [strict] for expressions any more - instead we have to use context rules,
  because all labels are now typed. In fact the bigger problem is that not even a slightest expression
  is left unchanged from the original program - everything have to be typed. Thus the semantics don't resemble
  the original language at all. Syntax-based definition in future will have to add type information and will be
  very problematic.

v2. Compute expression types at elaboration time only when needed - when they are arguments of ?: or method call.
  At runtime all expressions and statements will be left untyped - exactly as they are in the original program.
  In this approach each expression will only have to be parsed twice - once during standard top-down traversal
  of each code block, and second when computing the type of some ?: / method call parent. Another advantage is
  that just expression names will look different in right-hand-side of rules, other expressions will look the same.
  The main transformation done by elaboration will be:
  - resolving names into specific references to local vars / fields / full class names
  - resolving method calls into specific references to method signature and definition target.
  - desugar ?: into if + cast, thus integrating the expression type into cast expression.

4.ok elaboration of method calls, method signature lookup during elaboration.
4.1.ok. Separate compile-time processing from runtime processing in method-lookup logic. Thus it will be easier to move
  compile-time processing to elaboration phase later. Some new hacks for java API used.
4.2.ok. Rework the logic for java API methods. Add class-lib classes whenever possible.
  Custom rules for API should be required just for API method calls, in their final phase.
4.3.ok. Compute method invocation return type immediately after signature has been computed, but before actual execution.
  We should compute the return type simultaneously with the signature.
4.4.ok. Implement a new cell - <contextType>, that will hold staticCT or instanceCT depending on the context of the current
  block. Method/field lookup elaboration should be done based on this context. Should also be updated during method calls
  / return.

4.5.ok. Implement method signature elaboration.
4.6.ok. Make method call elaboration to be compatible with execution phase. Thus method invocation expressions
  produced at run time need not be elaborated.
4.7.ok. Fix array clone logic in the context of elaborated methods.

5.ok Additional cleanup part 1, once elaboration is functionally complete.

5.1.ok. Add a set of rules to convert a RawVal into appropriate TypedVal. This way we can use raw values in RHS
  of the rules in most cases, and once a RawVal will reach the top of computation it will be appropriately
  converted into a TypedVal. Thus our semantics will be closer to pure java.

General guidelines for elaboration and execution interoperability:
  R1. If a statement/expression is produced during execution phase, it need not to be typed.
    if an untyped expression is discovered in the top of computation it will be automatically
    elaborated in any phase, but unwrapped from elabRes only in execution phase.
  R2. If a pre-execution phase produces an expression that needs to be preserved, it should not be produced
    in the top of computation, otherwise the expression elaboration will start.
  R3. If a pre-execution phase produces an expression that needs to be executed immediately,
    it should be ready-typed. Typed expressions in the top of computation are executed immediately in any phase.

5.2.ok. Make the whole elaboration to be compatible with the execution phase. Revert all expressions produced
  at runtime to be in the state prior to the elaboration refactoring - thus unelaborated and more concise.
  We call this feature elaboration-execution interoperability.
5.3.ok. Rethink methodClosure :: methodType content to be more concise.
5.4.ok. Optimize method invocation / elaboration logic. Eliminate redundant constructs.

6. Cleanup the elaboration mechanism. Reduce the amount of auxiliary constructs.
6.1.ok. Introduced the predicate customElabChildren and removed customElabInit. The new predicate will replace
  several old ones.
6.2.ok. Eliminated elabInit wrapper. Reduced the predicate customElabHeat to customElabChildren.
6.3.ok. Eliminated the predicate customElabDisposeStart.
6.4. Eliminate all custom elaboration predicates except customElabChildren() and isElabNaked(_).
6.5. Make the elaboration of expressions naked. This way we can use strictness rules for expressions
  in the elaboration phase, and context rules in execution phase.

7. Invert the condition for labels elaborated by default:
  Right now we specify the labels that should not be elaborated by default, and do default elaboration
    for all other labels.
  This strategy is problematic because whenever we introduce a new language construct that could be
    desugared into existing constructs at elaboration phase, we need to add it to the list of exceptions.
    LocalVarDec is a good example. If we don't add them to the list of custom elab init, the results of
    our execution will depend on the order of rules in the compiled maude file.
  We need to do the opposite: Specify the list of labels for which we perform default elaboration,
    perform custom elaboration case by case, and for all other labels we will expect other rules to rewrite
    them into labels with known elaboration rules.

  When elaborating a block, in order to distinguish between an unelaborated
and an elaborated block, we will wrap elaborated blocks into elab(...).
