    Plan for the refactoring of semantics inspired by JBook:

  Separation of static and dynamic semantics.
Static semantics should compute anything that traditionally is computed at compile time.
Dynamic semantics should compute just what is computed at runtime. More precisely, we have to
move to the static semantics the following:
  - Deduction of compile-time type for each expression.
  - The right signature on method overloading.
  - Names lookup - resolution of each name into a fully-qualified name,
  or simple name, by case.

  Given that there is some dependence between those steps, we have to perform
those steps in certain order. Moreover, now we have to preprocess statement blocks before executing them -
the content of methods, static and instance initializers.
  So, we have to perform the refactoring in the following four steps:
1.ok. Perform a preprocessing of blocks, that recursively visits each term of the block but leves it untouched. This will be a new preprocessign step,
  after the preprocessing of classes members.
  It should not be a new global preprocessing. Instead it will be performed for each class after its members have been collected and the class reached the phase MembersProcessedCPP.
  Over this preprocessing we will be able to add certain transformations for certain KLabels.
2. Implement names lookup in static semantics.
2.1.ok Implement elaboration of ExprName(X) into localVar or Field.
    We need the following:
2.1.1.ok. Perform the hollow elaboration left to right in all KLists. This way local vars defined
    in a previous statement will be accessible in the next statement.
2.1.2.ok Create a new environment each time we meet an elab('Block).
  The easiest way to store environments during elaboration is as a stack of sets.
  Each time we enter a new block the new stack will be a copy of the previous stack.
2.1.3.ok Restore the environment each time we leave an elab('Block)
2.1.4.ok Save an entry in the environment each time we declare a var.
2.1.5.ok Do the desugaring of 'ExprName(X) into localVar(X)  if it is in the Env, or Field otherwise.

2.2. Elaborate qualified expression names, no packages yet.
2.2.1.ok. Elaborate This as qualifier.
2.2.2.ok. Elaborate Class as qualifier for static fields.
2.2.3.ok. Elaborate Object ref as qualifier for instance fields.
  Object ref Could be localVar, Field or any complex expression of type Ref.
  In addition to elabRes we have to add another type of elaboration result -
  K ::: T - the elaborated qualifier. K is the original expression,
  T is the type of that expression. Something similar to
  objectClosure, but instead of an object we now have a type.
  Thus, in order to resolve qualifiers we need to resolve expression types
  at elaboration phase.

2.2.4.ok. Move elaboration to a separate preprocessing phase, after all classes
  reached the state MembersProcessedCPP. We need class member declarations
  to be processed in order to proceed with block elaboration.
  Otherwise I might need to access the environment of a class whose members
  were not preprocessed, thus don't have its environment computed yet.

2.3.ok. Elaborate other minor expressions.
2.3.1.ok. Elaborate reference cast.
2.3.2.ok. Elaborate for variable declarations.
2.3.3.ok. Elaborate catch variable declarations.
2.3.4.ok. Eliminate elaboration for .K, Id and Type.
2.3.5.ok. Elaborate super.<field> expressions - semantics doubled at runtime and compile time.

2.4.ok. Use elaboration-phase data for field lookup at runtime.
2.4.1.ok. Static and instance field lookup in classes.
2.4.2.ok. Resolve static fields with instance qualifier.
2.4.3.ok. Resolve fields qualified with a reference to interface.

2.5.ok. Elaborate classes in the presence of packages.
2.6.ok. Elaborate names in the presence of inner classes.
2.7.ok. Refactor methods configuration. Now each method is elaborated in its defining class only.

At this step, all tests except array-related and some conditional-operator-related pass.

3. Implement expression type checking and annotation during elaboration.
3.1.ok. Annotate the type of localVar, fieldLookup, staticFieldLookup terms.
  Also other additional terms required to preserve all the passing tests (as for the end of step 2).

4. Invert the condition for labels elaborated by default:
  Right now we specify the labels that should not be elaborated by default, and do default elaboration
    for all other labels.
  This strategy is problematic because whenever we introduce a new language construct that could be
    desugared into existing constructs at elaboration phase, we need to add it to the list of exceptions.
    LocalVarDec is a good example. If we don't add them to the list of custom elab init, the results of
    our execution will depend on the order of rules in the compiled maude file.
  We need to do the opposite: Specify the list of labels for which we perform default elaboration,
    perform custom elaboration case by case, and for all other labels we will expect other rules to rewrite
    them into labels with known elaboration rules.

5. Implement method signature lookup during elaboration.

  When elaborating a block, in order to distinguish between an unelaborated
and elaborated block, we will wrap elaborated blocks into elab(...).
