Recommendations:
  1. Connect to VM through ssh port 3022.
  2. Set the "lines of scrollback" option in your SSH client to at least 7000. Otherwise you won't be able to see the whole configuration for failing programs.
  2. We recommend a separate connection through a sftp client through which you can view/edit files on the VM through the editor of your choice. The authors use expandrive.

Startup:
  1. Login with user/pass k/k
  2. All commands have to be run from java-semantics/src.

I. Execution:
  2. kjkompile.sh -v
    - this will compile k-java into maude representation.
  3. Now you can run the program of your choice using kjrun.sh. For example:

      kjrun.sh ../tests/01_smoke_tests/helloWorld.java

    You should see the stdout output followed by the configuration in the final state (in an xml-like format), with just 2 cells: <T> and <out>. This is because the rest of the cells are deleted at the end of the execution, when the execution is successful. There is one new file created in the current directory: helloWorld.java.pkast. This is the output of the preprocessing phase - the preprocessed program in AST format. It is the concatenation of all the classes in directory java/semantics/class-lib + the classes of the current test. The file serves as cache for multiple executions.

    IMPORTANT!
      You have to manually delete the pkast file each time you make changes to the original java file, when the execution produces an error, or if you halt the execution.

    Some tests contain multiple java files. This was required, for example, to test packages. Such tests are stored in a directory with name ending in ".java". For example, you can run

      kjrun.sh ../tests/61_packages/packages_21_unq_one_pack.java/

    More interesting programs could be found in kjrun.sh ../tests/31_diverse/

    Most directories under /tests contain a file starting with "test-plan" or "test plan" that explains the design of each test.

    If you want to see just the stdout content, you can use the option --split-none :

      kjrun.sh --timeout=0 --split-none ../tests/01_smoke_tests/helloWorld.java

    From the whole suite of 841 tests, right now 7 tests fail. This is because reading from stdin doesn't work. The tests used to work some time ago, the failure is due to a bug in K. Unfortunately this bug was not a priority for he K team, and is not yet fixed. We removed the failing tests to avoid inconveniences.

II. Execution with JDK:

      jdk-run.sh ../tests/01_smoke_tests/helloWorld.java

    This script wraps compilation and execution into one command, for convenience.

III. Execution of invalid programs.

  It would be more interesting to execute an invalid program. Then we will see the whole configuration stuck at the point when no rule could apply.

  We prepared 2 examples in the directory ../invalid.

    1. kjrun.sh ../invalid/invalidTypeConv.java

    This program passes the static phase but gets stuck during execution. Search for the cell <k> to see the remaining computation. The top K term is:

      normalize ( "x" :: int )

      This term tries to convert the value "x" to the 32-bit representation corresponding to int type, and there is no rule for such value types.

    We have to mention that String is modeled in K-Java as primitive type with native representation in K, not as Java class, for performance reasons.

    2. The second example gets stuck during static phase. We have to run it with a different option that executes only the static semantics, to see the result:

    kjrun.sh --prep-pretty ../invalid/undefinedClass.java

IV. Testing.

  Run kjtest.sh followed by a list of files/directories that you want to test. For example:

      kjtest.sh ../tests/01_smoke_tests/ ../invalid/

    The file test-results.xml contains details for failing tests. Each test is run on both JDK and K-Java and results are compared. Be aware that running the whole /tests directory takes 8 hours on a 2.6 ghz machine. It is possible to run multiple tests in parallel, but unfortunately VM was not configured to see multiple CPU cores.

V. State-space exploration
    Directory ../model-check/73_examples contains the examples used in the paper.
    For state-space exploration we have to recompile the definition with a different option:

      kjkompile.sh -v --threading-sync

      Now we can run the dining philosophers program:

    kjrun.sh --search --timeout=0 ../model-check/73_examples/Philosopher.java

    The output configuration for the deadlock case is filtered to display just the relevant cells (<thread> and the list inside <out>).

VI. LTL Model-checking.
    1. Running the wrong 2-threaded program (as in the paper):

      kjrun.sh --ltlmc="[]Ltl (this instanceof BlockingQueue ->Ltl (this.head) <= (this.tail))" \
    ../model-check/73_examples/queue_2_threads_2_wrong.java

    Execution returns true: the property holds for 2 threads.

    kjrun.sh --timeout=0 --ltlmc="[]Ltl (this instanceof BlockingQueue ->Ltl (this.head) <= (this.tail))" \
    ../model-check/73_examples/queue_4_threads_3_wrong.java > ltl.out

    The file ltl.out will contain the configurations along the execution path violating the property.

VII. Testing multi-threading.
  Multi-threading tests are in the directory ../model-check/72_threads

  1. kjkompile.sh -v --threading
  2. kjrun.sh --search --timeout=600 ../model-check/72_threads/threads_11_two_th_msg.java

  The output for each solution is the content of the cell <out>. Note that some tests may take too long or fail with "out of memory error". Our Java instance configured to run them has 16GB of RAM.

